#!/bin/bash

# =============================================================================
# SE Notes - Pre-commit Hook
# =============================================================================
# This hook runs before each commit to ensure code quality and security.
# To bypass (not recommended): git commit --no-verify
# =============================================================================

# Don't use set -e as we handle errors ourselves

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Counters
ERRORS=0
WARNINGS=0

# Helper functions
print_header() {
    echo -e "\n${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${BLUE}  $1${NC}"
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
}

print_success() {
    echo -e "  ${GREEN}✓${NC} $1"
}

print_error() {
    echo -e "  ${RED}✗${NC} $1"
    ((ERRORS++))
}

print_warning() {
    echo -e "  ${YELLOW}⚠${NC} $1"
    ((WARNINGS++))
}

print_info() {
    echo -e "  ${BLUE}ℹ${NC} $1"
}

# Get staged files
STAGED_GO_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.go$' || true)
STAGED_TS_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(ts|svelte)$' || true)
STAGED_JS_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(js|json)$' || true)
STAGED_ALL_FILES=$(git diff --cached --name-only --diff-filter=ACM)

print_header "SE Notes Pre-commit Checks"
echo -e "  Running checks on staged files..."

# =============================================================================
# 1. SECURITY CHECKS
# =============================================================================
print_header "1. Security Checks"

# Check for secrets and sensitive data
check_secrets() {
    local patterns=(
        # API Keys and Tokens
        'api[_-]?key\s*[:=]\s*["\x27][a-zA-Z0-9]{20,}["\x27]'
        'api[_-]?secret\s*[:=]\s*["\x27][a-zA-Z0-9]{20,}["\x27]'
        'access[_-]?token\s*[:=]\s*["\x27][a-zA-Z0-9]{20,}["\x27]'
        'auth[_-]?token\s*[:=]\s*["\x27][a-zA-Z0-9]{20,}["\x27]'
        
        # AWS
        'AKIA[0-9A-Z]{16}'
        'aws[_-]?secret[_-]?access[_-]?key'
        
        # Private Keys
        '-----BEGIN (RSA |EC |DSA |OPENSSH )?PRIVATE KEY-----'
        '-----BEGIN PGP PRIVATE KEY BLOCK-----'
        
        # Passwords
        'password\s*[:=]\s*["\x27][^"\x27]{8,}["\x27]'
        'passwd\s*[:=]\s*["\x27][^"\x27]{8,}["\x27]'
        
        # Database URLs with credentials
        '(mysql|postgres|mongodb)://[^:]+:[^@]+@'
        
        # JWT tokens
        'eyJ[a-zA-Z0-9_-]*\.eyJ[a-zA-Z0-9_-]*\.[a-zA-Z0-9_-]*'
        
        # Google
        'AIza[0-9A-Za-z_-]{35}'
        
        # GitHub
        'gh[pousr]_[A-Za-z0-9_]{36,}'
        
        # Slack
        'xox[baprs]-[0-9]{10,13}-[0-9]{10,13}[a-zA-Z0-9-]*'
    )
    
    local found_secrets=false
    
    for file in $STAGED_ALL_FILES; do
        if [[ -f "$file" ]]; then
            for pattern in "${patterns[@]}"; do
                if grep -qiE "$pattern" "$file" 2>/dev/null; then
                    if [[ "$found_secrets" == false ]]; then
                        print_error "Potential secrets detected:"
                        found_secrets=true
                    fi
                    echo -e "    ${RED}→${NC} $file: matches pattern '$pattern'"
                fi
            done
        fi
    done
    
    if [[ "$found_secrets" == false ]]; then
        print_success "No secrets detected in staged files"
    else
        return 1
    fi
}

# Check for sensitive file types
check_sensitive_files() {
    local sensitive_patterns=(
        '\.env$'
        '\.env\.'
        '\.pem$'
        '\.key$'
        '\.p12$'
        '\.pfx$'
        'id_rsa'
        'id_dsa'
        'id_ecdsa'
        'id_ed25519'
        '\.keystore$'
        '\.jks$'
        'credentials\.json$'
        'service[-_]?account.*\.json$'
    )
    
    local found_sensitive=false
    
    for file in $STAGED_ALL_FILES; do
        for pattern in "${sensitive_patterns[@]}"; do
            if echo "$file" | grep -qiE "$pattern"; then
                if [[ "$found_sensitive" == false ]]; then
                    print_error "Sensitive files detected:"
                    found_sensitive=true
                fi
                echo -e "    ${RED}→${NC} $file"
            fi
        done
    done
    
    if [[ "$found_sensitive" == false ]]; then
        print_success "No sensitive file types detected"
    else
        return 1
    fi
}

# Check for large files (>1MB)
check_large_files() {
    local large_files=false
    local max_size=1048576  # 1MB in bytes
    
    for file in $STAGED_ALL_FILES; do
        if [[ -f "$file" ]]; then
            local size=$(wc -c < "$file" 2>/dev/null || echo 0)
            if [[ $size -gt $max_size ]]; then
                if [[ "$large_files" == false ]]; then
                    print_warning "Large files detected (>1MB):"
                    large_files=true
                fi
                local size_mb=$(echo "scale=2; $size/1048576" | bc)
                echo -e "    ${YELLOW}→${NC} $file (${size_mb}MB)"
            fi
        fi
    done
    
    if [[ "$large_files" == false ]]; then
        print_success "No large files detected"
    fi
}

# Run security checks
check_secrets || true
check_sensitive_files || true
check_large_files

# =============================================================================
# 2. GO BACKEND CHECKS
# =============================================================================
if [[ -n "$STAGED_GO_FILES" ]]; then
    print_header "2. Go Backend Checks"
    
    # Check if Go is installed
    if ! command -v go &> /dev/null; then
        print_warning "Go not found, skipping Go checks"
    else
        # Go format check
        print_info "Running gofmt..."
        GOFMT_OUTPUT=$(gofmt -l $STAGED_GO_FILES 2>&1 || true)
        if [[ -n "$GOFMT_OUTPUT" ]]; then
            print_error "Go formatting issues found:"
            echo "$GOFMT_OUTPUT" | while read -r file; do
                echo -e "    ${RED}→${NC} $file"
            done
            print_info "Run 'gofmt -w <file>' to fix"
        else
            print_success "Go formatting OK"
        fi
        
        # Go vet
        print_info "Running go vet..."
        cd backend 2>/dev/null || true
        if go vet ./... 2>&1 | grep -v "^#"; then
            print_error "Go vet found issues"
        else
            print_success "Go vet passed"
        fi
        cd - > /dev/null 2>&1 || true
        
        # Go build check
        print_info "Checking Go build..."
        cd backend 2>/dev/null || true
        if go build -o /dev/null ./cmd/server/ 2>&1; then
            print_success "Go build successful"
        else
            print_error "Go build failed"
        fi
        cd - > /dev/null 2>&1 || true
        
        # Check for common Go issues
        print_info "Checking for common issues..."
        go_issues=false
        
        for file in $STAGED_GO_FILES; do
            # Check for fmt.Println (should use log)
            if grep -n 'fmt\.Println\|fmt\.Printf' "$file" 2>/dev/null | grep -v '_test\.go'; then
                if [[ "$go_issues" == false ]]; then
                    print_warning "Consider using log instead of fmt for output:"
                    go_issues=true
                fi
                grep -n 'fmt\.Println\|fmt\.Printf' "$file" | head -3 | while read -r line; do
                    echo -e "    ${YELLOW}→${NC} $file:$line"
                done
            fi
            
            # Check for TODO/FIXME comments
            if grep -n 'TODO\|FIXME\|XXX\|HACK' "$file" 2>/dev/null; then
                print_warning "Found TODO/FIXME in $file"
            fi
        done
        
        if [[ "$go_issues" == false ]]; then
            print_success "No common issues found"
        fi
    fi
else
    print_header "2. Go Backend Checks"
    print_info "No Go files staged, skipping"
fi

# =============================================================================
# 3. FRONTEND CHECKS
# =============================================================================
if [[ -n "$STAGED_TS_FILES" ]] || [[ -n "$STAGED_JS_FILES" ]]; then
    print_header "3. Frontend Checks"
    
    # Check if we're in the frontend directory or have package.json
    if [[ -d "frontend" ]]; then
        cd frontend
        
        # Check if node_modules exists
        if [[ ! -d "node_modules" ]]; then
            print_warning "node_modules not found, run 'npm install' first"
        else
            # TypeScript check
            print_info "Running svelte-check..."
            if npx svelte-check --threshold error 2>&1 | tail -5; then
                print_success "Svelte check passed"
            else
                print_warning "Svelte check had warnings (non-blocking)"
            fi
            
            # Check for console.log statements
            print_info "Checking for console.log statements..."
            local console_found=false
            for file in $STAGED_TS_FILES; do
                if [[ -f "../$file" ]] && grep -n 'console\.log' "../$file" 2>/dev/null; then
                    if [[ "$console_found" == false ]]; then
                        print_warning "console.log statements found (remove before production):"
                        console_found=true
                    fi
                fi
            done
            if [[ "$console_found" == false ]]; then
                print_success "No console.log statements"
            fi
        fi
        
        cd - > /dev/null
    fi
else
    print_header "3. Frontend Checks"
    print_info "No TypeScript/Svelte files staged, skipping"
fi

# =============================================================================
# 4. GENERAL CHECKS
# =============================================================================
print_header "4. General Checks"

# Check for merge conflict markers
print_info "Checking for merge conflict markers..."
CONFLICT_FOUND=false
for file in $STAGED_ALL_FILES; do
    # Skip hook files and shell scripts
    if [[ "$file" == *.sh ]] || [[ "$file" == .githooks/* ]]; then
        continue
    fi
    if [[ -f "$file" ]]; then
        if grep -qE '^(<{7}|={7}|>{7})' "$file" 2>/dev/null; then
            if [[ "$CONFLICT_FOUND" == false ]]; then
                print_error "Merge conflict markers found:"
                CONFLICT_FOUND=true
            fi
            echo -e "    ${RED}→${NC} $file"
        fi
    fi
done
if [[ "$CONFLICT_FOUND" == false ]]; then
    print_success "No merge conflict markers"
fi

# Check for trailing whitespace (skip binary and hook files)
print_info "Checking for trailing whitespace..."
TRAILING_FOUND=false
for file in $STAGED_ALL_FILES; do
    if [[ "$file" == .githooks/* ]] || [[ "$file" == *.sh ]]; then
        continue
    fi
    if [[ -f "$file" ]] && file "$file" | grep -q text; then
        WS=$(grep -n ' $' "$file" 2>/dev/null | head -3 || true)
        if [[ -n "$WS" ]]; then
            if [[ "$TRAILING_FOUND" == false ]]; then
                print_warning "Trailing whitespace found (consider fixing):"
                TRAILING_FOUND=true
            fi
            echo -e "    ${YELLOW}→${NC} $file"
        fi
    fi
done
if [[ "$TRAILING_FOUND" == false ]]; then
    print_success "No trailing whitespace"
fi

# Check for debugger statements (JS/TS files only)
print_info "Checking for debugger statements..."
DEBUGGER_FOUND=false
for file in $STAGED_ALL_FILES; do
    if [[ "$file" == *.ts ]] || [[ "$file" == *.js ]] || [[ "$file" == *.svelte ]]; then
        if grep -qn 'debugger' "$file" 2>/dev/null; then
            if [[ "$DEBUGGER_FOUND" == false ]]; then
                print_error "Debugger statements found:"
                DEBUGGER_FOUND=true
            fi
            grep -n 'debugger' "$file" | while read -r line; do
                echo -e "    ${RED}→${NC} $file:$line"
            done
        fi
    fi
done
if [[ "$DEBUGGER_FOUND" == false ]]; then
    print_success "No debugger statements"
fi

# =============================================================================
# 5. SUMMARY
# =============================================================================
print_header "Summary"

FINAL_STATUS="success"
if [[ $ERRORS -gt 0 ]]; then
    echo -e "  ${RED}✗ $ERRORS error(s) found${NC}"
    echo -e "  ${YELLOW}⚠ $WARNINGS warning(s) found${NC}"
    echo ""
    echo -e "  ${RED}Commit blocked.${NC} Please fix the errors above."
    echo -e "  Use ${YELLOW}git commit --no-verify${NC} to bypass (not recommended)"
    FINAL_STATUS="fail"
elif [[ $WARNINGS -gt 0 ]]; then
    echo -e "  ${GREEN}✓ No errors${NC}"
    echo -e "  ${YELLOW}⚠ $WARNINGS warning(s) found${NC}"
    echo ""
    echo -e "  ${GREEN}Commit allowed.${NC} Consider addressing warnings."
else
    echo -e "  ${GREEN}✓ All checks passed!${NC}"
fi

# =============================================================================
# 6. DASHCODE REPORTING
# =============================================================================
DASHCODE_URL="http://localhost:3001"
REPO_ID="e8450e26-c573-4aee-af1b-248405af0acc"

COMMIT_HASH="$(git rev-parse HEAD 2>/dev/null || echo 'staged')"
BRANCH="$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo 'unknown')"
AUTHOR="$(git config user.name 2>/dev/null || echo 'unknown')"
STAGED_COUNT=$(echo "$STAGED_ALL_FILES" | wc -w | tr -d ' ')

RESULTS="[{\"type\":\"security\",\"status\":\"pass\",\"output\":\"Security checks completed\",\"durationMs\":0,\"exitCode\":0},{\"type\":\"general\",\"status\":\"pass\",\"output\":\"$ERRORS errors, $WARNINGS warnings\",\"durationMs\":0,\"exitCode\":0}]"
META="{\"author\":\"$AUTHOR\",\"stagedFiles\":$STAGED_COUNT,\"errors\":$ERRORS,\"warnings\":$WARNINGS}"
PAYLOAD="{\"repoId\":\"$REPO_ID\",\"commitHash\":\"$COMMIT_HASH\",\"branch\":\"$BRANCH\",\"trigger\":\"pre-commit\",\"status\":\"$FINAL_STATUS\",\"durationMs\":0,\"meta\":$META,\"results\":$RESULTS}"

print_header "Dashcode Tracking"
if curl -s -X POST -H "Content-Type: application/json" -d "$PAYLOAD" "$DASHCODE_URL/api/hooks/report" --max-time 5 >/dev/null 2>&1; then
    print_success "Commit tracked successfully"
    COMMIT_SHORT="$(git rev-parse --short HEAD 2>/dev/null || echo 'staged')"
    echo -e "  ${GREEN}→${NC} $COMMIT_SHORT: $(git log -1 --pretty=%s 2>/dev/null || echo 'new commit')"
else
    print_warning "Could not reach Dashcode"
fi

echo ""
[[ "$FINAL_STATUS" == "fail" ]] && exit 1 || exit 0
